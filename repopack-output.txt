================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-07-29T18:45:56.179Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
include/
  assembler.h
  code_generation.h
  constants.h
  data_generation.h
  first_pass.h
  macro_processor.h
  second_pass.h
  symbol_table.h
  utils.h
src/
  assembler.c
  code_generation.c
  data_generation.c
  first_pass.c
  macro_processor.c
  second_pass.c
  symbol_table.c
  utils.c
makefile
README.md

================================================================
Repository Files
================================================================

================
File: include/assembler.h
================
#ifndef ASSEMBLER_H
#define ASSEMBLER_H

#include <stdbool.h>

/* Constants */
#define MAX_FILENAME 256

/* Function Prototypes */

/**
 * Main entry point for the assembler.
 * Processes each input file and generates output files.
 */
int main(int argc, char *argv[]);

/**
 * Cleans up any resources allocated during the assembly process.
 * Should be called before the program exits.
 */
void cleanup_resources();

/**
 * Performs the first pass of the assembly process.
 * Builds the symbol table and processes directives.
 */
bool first_pass(const char *filename);

/**
 * Performs the second pass of the assembly process.
 * Generates machine code and resolves symbols.
 */
bool second_pass(const char *input_filename, const char *ob_filename, 
                 const char *ext_filename, const char *ent_filename);

/**
 * Processes macros in the input file and generates an expanded source file.
 */
bool process_macros(const char *input_filename, const char *output_filename);

#endif /* ASSEMBLER_H */

================
File: include/code_generation.h
================
#ifndef CODE_GENERATION_H
#define CODE_GENERATION_H

#include <stdbool.h>
#include "constants.h"

typedef struct {
    const char *name;
    int opcode;
    int operand_count;
} Instruction;

/* Function Prototypes */

/**
 * Generates machine code for a given operation and its operands.
 * 
 * @param operation The assembly operation (e.g., "mov", "add")
 * @param operands The operands for the operation
 * @param code Pointer to a MachineCode struct to store the generated code
 * @return true if code generation was successful, false otherwise
 */
bool generate_machine_code(const char *operation, const char *operands, MachineCode *code);

/**
 * Determines the addressing mode of a given operand.
 * 
 * @param operand The operand to analyze
 * @return The addressing mode as defined in the AddressingMode enum
 */
AddressingMode get_addressing_mode(const char *operand);

/**
 * Encodes an individual operand into its machine code representation.
 * 
 * @param operand The operand to encode
 * @param value Pointer to store the encoded value
 * @param is_external Pointer to a bool indicating if the operand is an external reference
 * @return true if encoding was successful, false otherwise
 */
bool encode_operand(const char *operand, int *value, bool *is_external);

#endif /* CODE_GENERATION_H */

================
File: include/constants.h
================
#ifndef CONSTANTS_H
#define CONSTANTS_H

#include <stdbool.h>

/* General constants */
#define WORD_SIZE 15
#define MEMORY_SIZE 4096
#define MAX_LINE_LENGTH 80
#define MAX_LABEL_LENGTH 31
#define MAX_OPERATION_LENGTH 10
#define MAX_OPERAND_LENGTH 20
#define MAX_FILENAME 256
#define MAX_SYMBOL_LENGTH 31

/* Assembler limits */
#define MAX_SYMBOLS 1000
#define MAX_DATA_SIZE 1000
#define MAX_MACROS 100
#define MAX_MACRO_LINES 100

/* Memory addresses */
#define MEMORY_START 100

/* Data ranges */
#define MAX_POSITIVE_VALUE 8191  /* 2^13 - 1, for 14-bit signed integer */
#define MIN_NEGATIVE_VALUE -8192 /* -2^13, for 14-bit signed integer */

/* Assembler directives */
#define DIRECTIVE_DATA ".data"
#define DIRECTIVE_STRING ".string"
#define DIRECTIVE_ENTRY ".entry"
#define DIRECTIVE_EXTERN ".extern"

/* File extensions */
#define SOURCE_EXTENSION ".as"
#define OBJECT_EXTENSION ".ob"
#define ENTRIES_EXTENSION ".ent"
#define EXTERNALS_EXTENSION ".ext"
#define EXPANDED_SOURCE_EXTENSION ".am"

/* Enum for symbol types */
typedef enum {
    SYMBOL_UNKNOWN,
    SYMBOL_CODE,
    SYMBOL_DATA,
    SYMBOL_ENTRY,
    SYMBOL_EXTERNAL
} SymbolType;

/* Enum for addressing modes */
typedef enum {
    ADDR_IMMEDIATE,
    ADDR_DIRECT,
    ADDR_RELATIVE,
    ADDR_REGISTER
} AddressingMode;

/* Enum for A, R, E bits */
typedef enum {
    ARE_ABSOLUTE = 4,    /* 100 */
    ARE_RELOCATABLE = 2, /* 010 */
    ARE_EXTERNAL = 1     /* 001 */
} AREType;

/* Machine Code structure */
typedef struct {
    int first_word;
    int second_word;
    int third_word;
    bool second_word_exists;
    bool third_word_exists;
    bool is_external_reference;
    char external_symbol[MAX_SYMBOL_LENGTH + 1];
} MachineCode;

/* Global variables */
extern int IC;  /* Instruction Counter */
extern int DC;  /* Data Counter */

#endif /* CONSTANTS_H */

================
File: include/data_generation.h
================
#ifndef DATA_GENERATION_H
#define DATA_GENERATION_H

#include <stdbool.h>
#include <stdio.h>

/* Constants */
#define MAX_DATA_SIZE 1000
#define MAX_DATA_VALUE 8191  // Maximum positive value for 14-bit signed integer
#define MIN_DATA_VALUE -8192 // Minimum negative value for 14-bit signed integer

/* Function Prototypes */

bool process_data_directive(const char *operands);
bool process_string_directive(const char *operands);
bool process_entry_extern_directive(const char *directive, const char *operands);
void reset_data_counter();
int get_data_counter();
void write_data_image(FILE *file);

#endif /* DATA_GENERATION_H */

================
File: include/first_pass.h
================
#ifndef FIRST_PASS_H
#define FIRST_PASS_H

#include <stdbool.h>
#include "constants.h"

/* Function Prototypes */

/* Main function for the first pass */
bool first_pass(const char *filename);

/* Helper functions */
bool process_line(const char *line, int line_number);

/* Extern declarations for functions from other modules that first_pass.c might use */
extern bool add_symbol(const char *name, int value, SymbolType type);
extern bool is_valid_label(const char *label);
extern bool is_reserved_word(const char *word);
extern void update_data_symbols(int ic_value);
extern bool process_data_directive(const char *operands);
extern bool process_string_directive(const char *operands);
extern bool process_entry_extern_directive(const char *directive, const char *operands);

/* Extern declarations for global variables that first_pass.c might use */
extern int IC;  /* Instruction Counter */
extern int DC;  /* Data Counter */

#endif /* FIRST_PASS_H */

================
File: include/macro_processor.h
================
#ifndef MACRO_PROCESSOR_H
#define MACRO_PROCESSOR_H

#include <stdbool.h>
#include <stdio.h>
#include "constants.h"

/* Function Prototypes */

/* Main function to process macros */
bool process_macros(const char *input_filename, const char *output_filename);

/* Helper functions */
bool is_macro_definition(const char *line, char *macro_name);
bool is_macro_end(const char *line);
bool is_macro_call(const char *line, char *macro_name);
bool add_macro(const char *name, FILE *input);
bool expand_macro(const char *name, FILE *output);

/* Extern declarations for functions from other modules that macro_processor.c might use */
extern bool is_empty_or_comment(const char *line);
extern void trim(char *str);

#endif /* MACRO_PROCESSOR_H */

================
File: include/second_pass.h
================
#ifndef SECOND_PASS_H
#define SECOND_PASS_H

#include <stdbool.h>
#include <stdio.h>
#include "symbol_table.h"
#include "constants.h"

/* Function Prototypes */

/* Main function for the second pass */
bool second_pass(const char *input_filename, const char *ob_filename, 
                 const char *ext_filename, const char *ent_filename);

/* Helper functions */
bool process_line_second_pass(const char *line, int line_number, FILE *ob_file, FILE *ext_file, FILE *ent_file);
bool process_entry(const char *operands, FILE *ent_file);
bool process_instruction_second_pass(const char *operation, const char *operands, FILE *ob_file, FILE *ext_file);
void write_data_section(FILE *ob_file);

/* Extern declarations for functions from other modules that second_pass.c might use */
extern bool generate_machine_code(const char *operation, const char *operands, MachineCode *code);
extern bool is_empty_or_comment(const char *line);
extern bool parse_line(const char *line, char *label, char *operation, char *operands);
extern Symbol *get_symbol(const char *name);
extern bool is_external_symbol(const char *name);
extern void get_entry_symbols(EntrySymbol *entries, int *count);

/* Extern declarations for global variables that second_pass.c might use */
extern int IC;  /* Instruction Counter */
extern int DC;  /* Data Counter */

#endif /* SECOND_PASS_H */

================
File: include/symbol_table.h
================
#ifndef SYMBOL_TABLE_H
#define SYMBOL_TABLE_H

#include <stdbool.h>
#include "constants.h"

#define MAX_SYMBOLS 1000
#define MAX_ENTRIES 100

typedef struct {
    char name[MAX_SYMBOL_LENGTH + 1];
    int value;
    SymbolType type;
} Symbol;

typedef struct {
    char name[MAX_SYMBOL_LENGTH + 1];
    int value;
} EntrySymbol;

/* Function Prototypes */

void initialize_symbol_table();
bool add_symbol(const char *name, int value, SymbolType type);
Symbol *get_symbol(const char *name);
bool update_symbol_value(const char *name, int new_value);
void update_data_symbols(int ic_value);
void print_symbol_table();
bool is_external_symbol(const char *name);
void get_entry_symbols(EntrySymbol *entries, int *count);
void free_symbol_table();

#endif /* SYMBOL_TABLE_H */

================
File: include/utils.h
================
#ifndef UTILS_H
#define UTILS_H

#include <stdbool.h>

/* Function Prototypes */

bool is_empty_or_comment(const char *line);
bool parse_line(const char *line, char *label, char *operation, char *operands);
void trim(char *str);
int string_to_int(const char *str, bool *success);
bool is_valid_label(const char *label);
bool is_reserved_word(const char *word);
void int_to_binary_string(int value, char *binary, int num_bits);
int binary_string_to_int(const char *binary);
bool is_valid_integer(const char *str, int min, int max);
void log_error(const char *format, ...);
void log_warning(const char *format, ...);
bool is_directive(const char *operation);

#endif /* UTILS_H */

================
File: makefile
================
# Compiler settings
CC := gcc
CFLAGS := -Wall -Wextra -pedantic -std=c99 -g

# Directories
SRC_DIR := src
INC_DIR := include
OBJ_DIR := obj
BIN_DIR := bin

# Source files and object files
SRCS := $(wildcard $(SRC_DIR)/*.c)
OBJS := $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

# Header files
DEPS := $(wildcard $(INC_DIR)/*.h)

# Executable name
TARGET := $(BIN_DIR)/assembler

# Phony targets
.PHONY: all clean

# Default target
all: $(TARGET)

# Rule to create the executable
$(TARGET): $(OBJS) | $(BIN_DIR)
	$(CC) $(CFLAGS) $^ -o $@

# Rule to compile source files into object files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c $(DEPS) | $(OBJ_DIR)
	$(CC) $(CFLAGS) -I$(INC_DIR) -c $< -o $@

# Rule to create directories
$(BIN_DIR) $(OBJ_DIR):
	mkdir -p $@

# Clean target
clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR)

# Include dependencies
-include $(OBJS:.o=.d)

# Rule to generate dependency files
$(OBJ_DIR)/%.d: $(SRC_DIR)/%.c | $(OBJ_DIR)
	@set -e; rm -f $@; \
	$(CC) -MM -I$(INC_DIR) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,$(OBJ_DIR)/\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$

# Debug target
debug: CFLAGS += -DDEBUG
debug: all

# Help target
help:
	@echo "Available targets:"
	@echo "  all    : Build the assembler (default target)"
	@echo "  clean  : Remove all generated files"
	@echo "  debug  : Build with debug symbols and DEBUG macro defined"
	@echo "  help   : Display this help message"

================
File: src/assembler.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "assembler.h"
#include "first_pass.h"
#include "second_pass.h"
#include "macro_processor.h"
#include "utils.h"
#include "symbol_table.h"

#define MAX_FILENAME 256

static void process_file(const char *base_filename);
static void generate_output_filenames(const char *base_filename, char *am_filename, char *ob_filename, char *ext_filename, char *ent_filename);

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file1> <file2> ...\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; i++) {
        process_file(argv[i]);
    }

    return EXIT_SUCCESS;
}

static void process_file(const char *base_filename) {
    char input_filename[MAX_FILENAME];
    char am_filename[MAX_FILENAME];
    char ob_filename[MAX_FILENAME];
    char ext_filename[MAX_FILENAME];
    char ent_filename[MAX_FILENAME];

    snprintf(input_filename, MAX_FILENAME, "%s.as", base_filename);
    generate_output_filenames(base_filename, am_filename, ob_filename, ext_filename, ent_filename);

    printf("Processing file: %s\n", input_filename);

    if (!process_macros(input_filename, am_filename)) {
        fprintf(stderr, "Error processing macros in file %s\n", input_filename);
        return;
    }

    initialize_symbol_table();

    if (!first_pass(am_filename)) {
        fprintf(stderr, "Error in first pass for file %s\n", am_filename);
        return;
    }

    if (!second_pass(am_filename, ob_filename, ext_filename, ent_filename)) {
        fprintf(stderr, "Error in second pass for file %s\n", am_filename);
        return;
    }

    printf("Successfully assembled %s\n", input_filename);
    cleanup_resources();
}

static void generate_output_filenames(const char *base_filename, char *am_filename, char *ob_filename, char *ext_filename, char *ent_filename) {
    snprintf(am_filename, MAX_FILENAME, "%s.am", base_filename);
    snprintf(ob_filename, MAX_FILENAME, "%s.ob", base_filename);
    snprintf(ext_filename, MAX_FILENAME, "%s.ext", base_filename);
    snprintf(ent_filename, MAX_FILENAME, "%s.ent", base_filename);
}

void cleanup_resources() {
    /* Free any global resources, close files, etc. */
    /* This function should be implemented based on your specific needs */
}

================
File: src/code_generation.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "code_generation.h"
#include "symbol_table.h"
#include "utils.h"

#define MAX_OPERANDS 2

static const Instruction instruction_set[] = {
    {"mov", 0, 2},
    {"cmp", 1, 2},
    {"add", 2, 2},
    {"sub", 3, 2},
    {"lea", 4, 2},
    {"clr", 5, 1},
    {"not", 6, 1},
    {"inc", 7, 1},
    {"dec", 8, 1},
    {"jmp", 9, 1},
    {"bne", 10, 1},
    {"red", 11, 1},
    {"prn", 12, 1},
    {"jsr", 13, 1},
    {"rts", 14, 0},
    {"stop", 15, 0}
};

static int get_register_number(const char *reg);
static const Instruction* find_instruction(const char *operation);

bool generate_machine_code(const char *operation, const char *operands, MachineCode *code) {
    char op1[MAX_OPERAND_LENGTH] = {0}, op2[MAX_OPERAND_LENGTH] = {0};
    const Instruction *instr = find_instruction(operation);
    
    if (!instr) {
        fprintf(stderr, "Unknown operation: %s\n", operation);
        return false;
    }

    if (instr->operand_count > 0) {
        sscanf(operands, "%s %s", op1, op2);
    }

    // Encode first word
    code->first_word = (instr->opcode << 6);
    if (instr->operand_count > 0) {
        AddressingMode src_addr = get_addressing_mode(op1);
        AddressingMode dst_addr = get_addressing_mode(op2);
        code->first_word |= (src_addr << 4) | (dst_addr << 2);
    }
    code->first_word |= ARE_ABSOLUTE;

    // Encode operands
    code->second_word_exists = code->third_word_exists = code->is_external_reference = false;

    if (instr->operand_count > 0) {
        int value;
        bool is_external;

        if (encode_operand(op1, &value, &is_external)) {
            code->second_word = value;
            code->second_word_exists = true;
            if (is_external) {
                code->is_external_reference = true;
                strncpy(code->external_symbol, op1, MAX_SYMBOL_LENGTH);
            }
        }

        if (instr->operand_count > 1 && encode_operand(op2, &value, &is_external)) {
            code->third_word = value;
            code->third_word_exists = true;
            if (is_external) {
                code->is_external_reference = true;
                strncpy(code->external_symbol, op2, MAX_SYMBOL_LENGTH);
            }
        }
    }

    return true;
}

static int get_register_number(const char *reg) {
    if (reg[0] == 'r' && reg[1] >= '0' && reg[1] <= '7' && reg[2] == '\0') {
        return reg[1] - '0';
    }
    return -1;
}

AddressingMode get_addressing_mode(const char *operand) {
    if (operand[0] == '#') return ADDR_IMMEDIATE;
    if (operand[0] == '*') return ADDR_RELATIVE;
    if (get_register_number(operand) != -1) return ADDR_REGISTER;
    return ADDR_DIRECT;
}

bool encode_operand(const char *operand, int *value, bool *is_external) {
    int reg_num;
    *is_external = false;

    if (operand[0] == '#') {
        *value = atoi(operand + 1);
        return true;
    }

    if ((reg_num = get_register_number(operand)) != -1) {
        *value = reg_num;
        return true;
    }

    if (operand[0] == '*') {
        reg_num = get_register_number(operand + 1);
        if (reg_num != -1) {
            *value = reg_num;
            return true;
        }
    }

    // Symbol
    Symbol *symbol = get_symbol(operand);
    if (symbol) {
        *value = symbol->value;
        *is_external = (symbol->type == SYMBOL_EXTERNAL);
        return true;
    }

    fprintf(stderr, "Invalid operand: %s\n", operand);
    return false;
}

static const Instruction* find_instruction(const char *operation) {
    for (size_t i = 0; i < sizeof(instruction_set) / sizeof(Instruction); i++) {
        if (strcmp(operation, instruction_set[i].name) == 0) {
            return &instruction_set[i];
        }
    }
    return NULL;
}

================
File: src/data_generation.c
================
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "data_generation.h"

#define MAX_DATA_SIZE 1000

static int data_image[MAX_DATA_SIZE];
static int data_counter = 0;

bool process_data_directive(const char *operands) {
    char *token;
    char *rest = strdup(operands);
    
    if (!rest) {
        fprintf(stderr, "Memory allocation failed\n");
        return false;
    }

    while ((token = strtok_r(rest, ",", &rest))) {
        /* Remove leading and trailing whitespace */
        while (isspace(*token)) token++;
        char *end = token + strlen(token) - 1;
        while (end > token && isspace(*end)) end--;
        *(end + 1) = 0;

        /* Convert to integer */
        char *endptr;
        long value = strtol(token, &endptr, 10);

        if (*endptr != '\0') {
            fprintf(stderr, "Invalid number in .data directive: %s\n", token);
            free(rest);
            return false;
        }

        if (value < -8192 || value > 8191) {
            fprintf(stderr, "Number out of range in .data directive: %ld\n", value);
            free(rest);
            return false;
        }

        if (data_counter >= MAX_DATA_SIZE) {
            fprintf(stderr, "Data segment full\n");
            free(rest);
            return false;
        }

        data_image[data_counter++] = (int)value;
    }

    free(rest);
    return true;
}

/* Implement other functions as needed */

void reset_data_counter() {
    data_counter = 0;
}

int get_data_counter() {
    return data_counter;
}

void write_data_image(FILE *file) {
    for (int i = 0; i < data_counter; i++) {
        fprintf(file, "%04d %05o\n", i + 100, data_image[i] & 0x7FFF);
    }
}

bool process_string_directive(const char *operands) {
    // Implementation for string directive
    // This is a placeholder implementation
    (void)operands; // Suppress unused parameter warning
    return true;
}

bool process_entry_extern_directive(const char *directive, const char *operands) {
    // Implementation for entry and extern directives
    // This is a placeholder implementation
    (void)directive; // Suppress unused parameter warning
    (void)operands;  // Suppress unused parameter warning
    return true;
}

================
File: src/first_pass.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "first_pass.h"
#include "symbol_table.h"
#include "utils.h"
#include "constants.h"
#include "data_generation.h"

int IC = MEMORY_START;  /* Instruction Counter */
int DC = 0;  /* Data Counter */

static bool process_label(const char *label);
static bool process_directive(const char *directive, const char *operands);
static bool process_instruction(const char *operation, const char *operands);
static int calculate_instruction_length(const char *operation, const char *operands);

bool first_pass(const char *filename) {
    FILE *file = fopen(filename, "r");
    char line[MAX_LINE_LENGTH];
    int line_number = 0;
    bool success = true;

    if (!file) {
        fprintf(stderr, "Error opening file %s\n", filename);
        return false;
    }

    while (fgets(line, sizeof(line), file)) {
        line_number++;
        line[strcspn(line, "\n")] = 0;  /* Remove newline character */

        if (is_empty_or_comment(line)) {
            continue;
        }

        if (!process_line(line, line_number)) {
            fprintf(stderr, "Error in line %d: %s\n", line_number, line);
            success = false;
        }
    }

    fclose(file);
    update_data_symbols(IC);
    return success;
}

bool process_line(const char *line, int line_number __attribute__((unused))) {
    char label[MAX_LABEL_LENGTH] = {0};
    char operation[MAX_OPERATION_LENGTH] = {0};
    char operands[MAX_LINE_LENGTH] = {0};

    if (!parse_line(line, label, operation, operands)) {
        return false;
    }

    if (label[0] != '\0' && !process_label(label)) {
        return false;
    }

    if (is_directive(operation)) {
        return process_directive(operation, operands);
    } else {
        return process_instruction(operation, operands);
    }
}

static bool process_label(const char *label) {
    if (!is_valid_label(label)) {
        fprintf(stderr, "Invalid label: %s\n", label);
        return false;
    }
    return add_symbol(label, IC, SYMBOL_CODE);
}

static bool process_directive(const char *directive, const char *operands) {
    if (strcmp(directive, "data") == 0) {
        return process_data_directive(operands);
    } else if (strcmp(directive, "string") == 0) {
        return process_string_directive(operands);
    } else if (strcmp(directive, "entry") == 0 || strcmp(directive, "extern") == 0) {
        return process_entry_extern_directive(directive, operands);
    }
    fprintf(stderr, "Unknown directive: %s\n", directive);
    return false;
}

static bool process_instruction(const char *operation, const char *operands) {
    int instruction_length = calculate_instruction_length(operation, operands);
    if (instruction_length == -1) {
        return false;
    }
    IC += instruction_length;
    return true;
}

static int calculate_instruction_length(const char *operation, const char *operands) {
    /* Implement logic to determine instruction length based on operation and operands */
    /* This is a placeholder implementation */
    (void)operation; /* Suppress unused parameter warning */
    (void)operands;  /* Suppress unused parameter warning */
    return 1;  /* Assume all instructions are 1 word long for simplicity */
}

================
File: src/macro_processor.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "macro_processor.h"

#define MAX_MACRO_NAME 31
#define MAX_MACRO_LINES 100
#define MAX_LINE_LENGTH 80
#define MAX_MACROS 100

typedef struct {
    char name[MAX_MACRO_NAME + 1];
    char lines[MAX_MACRO_LINES][MAX_LINE_LENGTH + 1];
    int line_count;
} Macro;

static Macro macro_table[MAX_MACROS];
static int macro_count = 0;

static Macro *find_macro(const char *name);

bool process_macros(const char *input_filename, const char *output_filename) {
    FILE *input = fopen(input_filename, "r");
    FILE *output = fopen(output_filename, "w");
    char line[MAX_LINE_LENGTH + 1];
    char macro_name[MAX_MACRO_NAME + 1];

    if (!input || !output) {
        fprintf(stderr, "Error opening files for macro processing\n");
        return false;
    }

    while (fgets(line, sizeof(line), input)) {
        if (is_macro_definition(line, macro_name)) {
            if (!add_macro(macro_name, input)) {
                fclose(input);
                fclose(output);
                return false;
            }
        } else if (is_macro_call(line, macro_name)) {
            if (!expand_macro(macro_name, output)) {
                fclose(input);
                fclose(output);
                return false;
            }
        } else {
            fputs(line, output);
        }
    }

    fclose(input);
    fclose(output);
    return true;
}

bool is_macro_definition(const char *line, char *macro_name) {
    return (sscanf(line, "macro %s", macro_name) == 1);
}

bool is_macro_end(const char *line) {
    return (strncmp(line, "endmacro", 8) == 0);
}

bool is_macro_call(const char *line, char *macro_name) {
    for (int i = 0; i < macro_count; i++) {
        if (strncmp(line, macro_table[i].name, strlen(macro_table[i].name)) == 0) {
            strcpy(macro_name, macro_table[i].name);
            return true;
        }
    }
    return false;
}

bool add_macro(const char *name, FILE *input) {
    if (macro_count >= MAX_MACROS) {
        fprintf(stderr, "Maximum number of macros exceeded\n");
        return false;
    }

    if (find_macro(name)) {
        fprintf(stderr, "Macro '%s' already defined\n", name);
        return false;
    }

    Macro *macro = &macro_table[macro_count++];
    strncpy(macro->name, name, MAX_MACRO_NAME);
    macro->name[MAX_MACRO_NAME] = '\0';
    macro->line_count = 0;

    char line[MAX_LINE_LENGTH + 1];
    while (fgets(line, sizeof(line), input) && !is_macro_end(line)) {
        if (macro->line_count < MAX_MACRO_LINES) {
            strncpy(macro->lines[macro->line_count], line, MAX_LINE_LENGTH);
            macro->lines[macro->line_count][MAX_LINE_LENGTH] = '\0';
            macro->line_count++;
        } else {
            fprintf(stderr, "Macro '%s' exceeds maximum lines\n", name);
            return false;
        }
    }

    return true;
}

bool expand_macro(const char *name, FILE *output) {
    Macro *macro = find_macro(name);
    if (!macro) {
        fprintf(stderr, "Macro '%s' not found\n", name);
        return false;
    }

    for (int i = 0; i < macro->line_count; i++) {
        fputs(macro->lines[i], output);
    }
    return true;
}

static Macro *find_macro(const char *name) {
    for (int i = 0; i < macro_count; i++) {
        if (strcmp(macro_table[i].name, name) == 0) {
            return &macro_table[i];
        }
    }
    return NULL;
}

================
File: src/second_pass.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "second_pass.h"
#include "symbol_table.h"
#include "code_generation.h"
#include "utils.h"
#include "constants.h"

extern int IC;  /* Instruction Counter */
extern int DC;  /* Data Counter */

static int instruction_counter = MEMORY_START;

bool second_pass(const char *input_filename, const char *ob_filename, 
                 const char *ext_filename, const char *ent_filename) {
    FILE *input_file, *ob_file, *ext_file, *ent_file;
    char line[MAX_LINE_LENGTH];
    int line_number = 0;
    bool success = true;

    input_file = fopen(input_filename, "r");
    ob_file = fopen(ob_filename, "w");
    ext_file = fopen(ext_filename, "w");
    ent_file = fopen(ent_filename, "w");

    if (!input_file || !ob_file || !ext_file || !ent_file) {
        fprintf(stderr, "Error opening files for second pass\n");
        return false;
    }

    /* Write header to object file */
    fprintf(ob_file, "%d %d\n", IC - MEMORY_START, DC);

    while (fgets(line, sizeof(line), input_file)) {
        line_number++;
        line[strcspn(line, "\n")] = 0;  /* Remove newline character */

        if (is_empty_or_comment(line)) {
            continue;
        }

        if (!process_line_second_pass(line, line_number, ob_file, ext_file, ent_file)) {
            fprintf(stderr, "Error in line %d: %s\n", line_number, line);
            success = false;
        }
    }

    write_data_section(ob_file);

    fclose(input_file);
    fclose(ob_file);
    fclose(ext_file);
    fclose(ent_file);

    return success;
}

bool process_line_second_pass(const char *line, int line_number, FILE *ob_file, FILE *ext_file, FILE *ent_file) {
    char label[MAX_LABEL_LENGTH] = {0};
    char operation[MAX_OPERATION_LENGTH] = {0};
    char operands[MAX_LINE_LENGTH] = {0};

    (void)line_number; /* Suppress unused parameter warning */

    if (!parse_line(line, label, operation, operands)) {
        return false;
    }

    if (is_directive(operation)) {
        if (strcmp(operation, "entry") == 0) {
            return process_entry(operands, ent_file);
        }
        /* Skip other directives in second pass */
        return true;
    } else {
        return process_instruction_second_pass(operation, operands, ob_file, ext_file);
    }
}

bool process_entry(const char *operands, FILE *ent_file) {
    Symbol *symbol = get_symbol(operands);
    if (!symbol) {
        fprintf(stderr, "Entry symbol %s not found\n", operands);
        return false;
    }
    fprintf(ent_file, "%s %04d\n", operands, symbol->value);
    return true;
}

bool process_instruction_second_pass(const char *operation, const char *operands, FILE *ob_file, FILE *ext_file) {
    MachineCode code;
    if (!generate_machine_code(operation, operands, &code)) {
        return false;
    }

    /* Write machine code to object file */
    fprintf(ob_file, "%04d %05o\n", instruction_counter, code.first_word);
    instruction_counter++;

    if (code.second_word_exists) {
        fprintf(ob_file, "%04d %05o\n", instruction_counter, code.second_word);
        instruction_counter++;
    }

    if (code.third_word_exists) {
        fprintf(ob_file, "%04d %05o\n", instruction_counter, code.third_word);
        instruction_counter++;
    }

    /* Handle external references */
    if (code.is_external_reference) {
        fprintf(ext_file, "%s %04d\n", code.external_symbol, instruction_counter - 1);
    }

    return true;
}

void write_data_section(FILE *ob_file) {
    /* Write data section to object file */
    /* This function should iterate through the data image and write it to the object file */
    /* Implement based on your data storage mechanism */
    (void)ob_file; /* Suppress unused parameter warning */
}

================
File: src/symbol_table.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "symbol_table.h"

#define HASH_SIZE 101

typedef struct SymbolNode {
    Symbol symbol;
    struct SymbolNode *next;
} SymbolNode;

static SymbolNode *hash_table[HASH_SIZE] = {NULL};

static unsigned int hash(const char *str) {
    unsigned int hash = 5381;
    int c;

    while ((c = *str++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash % HASH_SIZE;
}

void initialize_symbol_table() {
    for (int i = 0; i < HASH_SIZE; i++) {
        hash_table[i] = NULL;
    }
}

bool add_symbol(const char *name, int value, SymbolType type) {
    if (get_symbol(name) != NULL) {
        fprintf(stderr, "Symbol %s already exists\n", name);
        return false;
    }

    unsigned int index = hash(name);
    SymbolNode *new_node = (SymbolNode *)malloc(sizeof(SymbolNode));
    if (!new_node) {
        fprintf(stderr, "Memory allocation failed\n");
        return false;
    }

    strncpy(new_node->symbol.name, name, MAX_SYMBOL_LENGTH - 1);
    new_node->symbol.name[MAX_SYMBOL_LENGTH - 1] = '\0';
    new_node->symbol.value = value;
    new_node->symbol.type = type;
    new_node->next = hash_table[index];
    hash_table[index] = new_node;

    return true;
}

Symbol *get_symbol(const char *name) {
    unsigned int index = hash(name);
    SymbolNode *current = hash_table[index];

    while (current) {
        if (strcmp(current->symbol.name, name) == 0) {
            return &(current->symbol);
        }
        current = current->next;
    }

    return NULL;
}

bool update_symbol_value(const char *name, int new_value) {
    Symbol *symbol = get_symbol(name);
    if (symbol == NULL) {
        return false;
    }
    symbol->value = new_value;
    return true;
}

void update_data_symbols(int ic_value) {
    for (int i = 0; i < HASH_SIZE; i++) {
        SymbolNode *current = hash_table[i];
        while (current) {
            if (current->symbol.type == SYMBOL_DATA) {
                current->symbol.value += ic_value;
            }
            current = current->next;
        }
    }
}

void print_symbol_table() {
    printf("Symbol Table:\n");
    printf("Name\t\tValue\tType\n");
    for (int i = 0; i < HASH_SIZE; i++) {
        SymbolNode *current = hash_table[i];
        while (current) {
            printf("%-15s\t%d\t", current->symbol.name, current->symbol.value);
            switch (current->symbol.type) {
                case SYMBOL_CODE: printf("Code\n"); break;
                case SYMBOL_DATA: printf("Data\n"); break;
                case SYMBOL_EXTERNAL: printf("External\n"); break;
                case SYMBOL_ENTRY: printf("Entry\n"); break;
                case SYMBOL_UNKNOWN: printf("Unknown\n"); break;
            }
            current = current->next;
        }
    }
}

bool is_external_symbol(const char *name) {
    Symbol *symbol = get_symbol(name);
    return symbol != NULL && symbol->type == SYMBOL_EXTERNAL;
}

void get_entry_symbols(EntrySymbol *entries, int *count) {
    *count = 0;
    for (int i = 0; i < HASH_SIZE; i++) {
        SymbolNode *current = hash_table[i];
        while (current && *count < MAX_ENTRIES) {
            if (current->symbol.type == SYMBOL_ENTRY) {
                strncpy(entries[*count].name, current->symbol.name, MAX_SYMBOL_LENGTH - 1);
                entries[*count].name[MAX_SYMBOL_LENGTH - 1] = '\0';
                entries[*count].value = current->symbol.value;
                (*count)++;
            }
            current = current->next;
        }
    }
}

void free_symbol_table() {
    for (int i = 0; i < HASH_SIZE; i++) {
        SymbolNode *current = hash_table[i];
        while (current) {
            SymbolNode *temp = current;
            current = current->next;
            free(temp);
        }
        hash_table[i] = NULL;
    }
}

================
File: src/utils.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>
#include "utils.h"
#include "constants.h"

bool is_empty_or_comment(const char *line) {
    while (*line) {
        if (!isspace(*line)) {
            return (*line == ';');  // True if it's a comment, false otherwise
        }
        line++;
    }
    return true;  // Empty line
}

bool parse_line(const char *line, char *label, char *operation, char *operands) {
    const char *start = line;
    
    // Skip leading whitespace
    while (isspace(*start)) start++;

    // Check for empty line or comment
    if (*start == '\0' || *start == ';') {
        *label = *operation = *operands = '\0';
        return true;
    }

    // Parse label
    const char *colon = strchr(start, ':');
    if (colon) {
        size_t label_length = colon - start;
        if (label_length >= MAX_LABEL_LENGTH) {
            log_error("Label too long: %.*s", (int)label_length, start);
            return false;
        }
        strncpy(label, start, label_length);
        label[label_length] = '\0';
        start = colon + 1;
    } else {
        *label = '\0';
    }

    // Skip whitespace after label
    while (isspace(*start)) start++;

    // Parse operation
    const char *space = strchr(start, ' ');
    if (space) {
        size_t operation_length = space - start;
        if (operation_length >= MAX_OPERATION_LENGTH) {
            log_error("Operation too long: %.*s", (int)operation_length, start);
            return false;
        }
        strncpy(operation, start, operation_length);
        operation[operation_length] = '\0';
        start = space + 1;
    } else {
        strcpy(operation, start);
        *operands = '\0';
        return true;
    }

    // Skip whitespace after operation
    while (isspace(*start)) start++;

    // Parse operands
    strncpy(operands, start, MAX_LINE_LENGTH - 1);
    operands[MAX_LINE_LENGTH - 1] = '\0';
    trim(operands);

    return true;
}

void trim(char *str) {
    char *end;

    // Trim leading space
    while(isspace((unsigned char)*str)) str++;

    if(*str == 0)  // All spaces?
        return;

    // Trim trailing space
    end = str + strlen(str) - 1;
    while(end > str && isspace((unsigned char)*end)) end--;

    // Write new null terminator character
    end[1] = '\0';
}

int string_to_int(const char *str, bool *success) {
    char *endptr;
    long value = strtol(str, &endptr, 10);

    if (endptr == str || *endptr != '\0') {
        *success = false;
        return 0;
    }

    if (value < MIN_NEGATIVE_VALUE || value > MAX_POSITIVE_VALUE) {
        *success = false;
        return 0;
    }

    *success = true;
    return (int)value;
}

bool is_valid_label(const char *label) {
    if (!isalpha(*label)) {
        return false;  // First character must be a letter
    }

    size_t len = strlen(label);
    if (len > MAX_LABEL_LENGTH) {
        return false;  // Label is too long
    }

    for (size_t i = 1; i < len; i++) {
        if (!isalnum(label[i])) {
            return false;  // Must contain only letters and digits
        }
    }

    return !is_reserved_word(label);
}

bool is_reserved_word(const char *word) {
    static const char *reserved_words[] = {
        "mov", "cmp", "add", "sub", "lea", "clr", "not", "inc", "dec",
        "jmp", "bne", "red", "prn", "jsr", "rts", "stop", "data", "string",
        "entry", "extern", "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7"
    };
    static const int num_reserved_words = sizeof(reserved_words) / sizeof(reserved_words[0]);

    for (int i = 0; i < num_reserved_words; i++) {
        if (strcmp(word, reserved_words[i]) == 0) {
            return true;
        }
    }
    return false;
}

void int_to_binary_string(int value, char *binary, int num_bits) {
    for (int i = num_bits - 1; i >= 0; i--) {
        binary[num_bits - 1 - i] = (value & (1 << i)) ? '1' : '0';
    }
    binary[num_bits] = '\0';
}

int binary_string_to_int(const char *binary) {
    int result = 0;
    while (*binary) {
        result = (result << 1) + (*binary - '0');
        binary++;
    }
    return result;
}

bool is_valid_integer(const char *str, int min, int max) {
    char *endptr;
    long value = strtol(str, &endptr, 10);

    if (endptr == str || *endptr != '\0') {
        return false;  // Not a valid integer
    }

    return (value >= min && value <= max);
}

void log_error(const char *format, ...) {
    va_list args;
    va_start(args, format);
    fprintf(stderr, "Error: ");
    vfprintf(stderr, format, args);
    fprintf(stderr, "\n");
    va_end(args);
}

void log_warning(const char *format, ...) {
    va_list args;
    va_start(args, format);
    fprintf(stderr, "Warning: ");
    vfprintf(stderr, format, args);
    fprintf(stderr, "\n");
    va_end(args);
}

bool is_directive(const char *operation) {
    return (strcmp(operation, "data") == 0 ||
            strcmp(operation, "string") == 0 ||
            strcmp(operation, "entry") == 0 ||
            strcmp(operation, "extern") == 0);
}
