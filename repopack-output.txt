================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-07-29T15:09:11.973Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
include/
  assembler.h
  code_generation.h
  constants.h
  data_generation.h
  first_pass.h
  macro_processor.h
  second_pass.h
  symbol_table.h
  utils.h
obj/
  assembler.d
  code_generation.d
  data_generation.d
  first_pass.d
  macro_processor.d
  second_pass.d
  symbol_table.d
  utils.d
src/
  assembler.c
  code_generation.c
  data_generation.c
  first_pass.c
  macro_processor.c
  second_pass.c
  symbol_table.c
  utils.c
makefile
README.md

================================================================
Repository Files
================================================================

================
File: include/assembler.h
================
#ifndef ASSEMBLER_H
#define ASSEMBLER_H

#include <stdbool.h>

/* Constants */
#define MAX_FILENAME 256

/* Function Prototypes */

/* assembler.c */
int main(int argc, char *argv[]);
void cleanup_resources();

/* first_pass.c */
bool first_pass(const char *filename);

/* second_pass.c */
bool second_pass(const char *input_filename, const char *ob_filename, 
                 const char *ext_filename, const char *ent_filename);

/* macro_processor.c */
bool process_macros(const char *input_filename, const char *output_filename);

#endif /* ASSEMBLER_H */

================
File: include/code_generation.h
================
#ifndef CODE_GENERATION_H
#define CODE_GENERATION_H

#include <stdbool.h>

/* Constants */
#define MAX_OPERANDS 2
#define MAX_SYMBOL_LENGTH 31
#define MAX_OPERAND_LENGTH 20

/* Enums */
typedef enum {
    ADDRESSING_IMMEDIATE,
    ADDRESSING_DIRECT,
    ADDRESSING_REGISTER_INDIRECT,
    ADDRESSING_REGISTER_DIRECT
} AddressingMode;

/* Structs */
typedef struct {
    const char *name;
    int opcode;
    int operand_count;
} Instruction;

typedef struct {
    int first_word;
    int second_word;
    int third_word;
    bool second_word_exists;
    bool third_word_exists;
    bool is_external_reference;
    char external_symbol[MAX_SYMBOL_LENGTH + 1];
} MachineCode;

/* Function Prototypes */

/* Main function to generate machine code */
bool generate_machine_code(const char *operation, const char *operands, MachineCode *code);

/* Helper functions */
static int get_register_number(const char *reg);
static AddressingMode get_addressing_mode(const char *operand);
static bool encode_operand(const char *operand, int *value, bool *is_external);

/* Extern declarations for functions from other modules that code_generation.c might use */
extern Symbol *get_symbol(const char *name);
extern bool is_external_symbol(const char *name);

/* The instruction set */
extern const Instruction instruction_set[];

#endif /* CODE_GENERATION_H */

================
File: include/constants.h
================
#ifndef CONSTANTS_H
#define CONSTANTS_H

/* General constants */
#define WORD_SIZE 15
#define MEMORY_SIZE 4096
#define MAX_LINE_LENGTH 80
#define MAX_LABEL_LENGTH 31
#define MAX_OPERATION_LENGTH 10
#define MAX_OPERAND_LENGTH 20
#define MAX_FILENAME 256

/* Assembler limits */
#define MAX_SYMBOLS 1000
#define MAX_DATA_SIZE 1000
#define MAX_MACROS 100
#define MAX_MACRO_LINES 100

/* Memory addresses */
#define MEMORY_START 100

/* Data ranges */
#define MAX_POSITIVE_VALUE 8191  // 2^13 - 1, for 14-bit signed integer
#define MIN_NEGATIVE_VALUE -8192 // -2^13, for 14-bit signed integer

/* Assembler directives */
#define DIRECTIVE_DATA ".data"
#define DIRECTIVE_STRING ".string"
#define DIRECTIVE_ENTRY ".entry"
#define DIRECTIVE_EXTERN ".extern"

/* File extensions */
#define SOURCE_EXTENSION ".as"
#define OBJECT_EXTENSION ".ob"
#define ENTRIES_EXTENSION ".ent"
#define EXTERNALS_EXTENSION ".ext"
#define EXPANDED_SOURCE_EXTENSION ".am"

/* Enum for symbol types */
typedef enum {
    SYMBOL_UNKNOWN,
    SYMBOL_CODE,
    SYMBOL_DATA,
    SYMBOL_ENTRY,
    SYMBOL_EXTERNAL
} SymbolType;

/* Enum for addressing modes */
typedef enum {
    ADDR_IMMEDIATE,
    ADDR_DIRECT,
    ADDR_RELATIVE,
    ADDR_REGISTER
} AddressingMode;

/* Enum for A, R, E bits */
typedef enum {
    ARE_ABSOLUTE = 4,    // 100
    ARE_RELOCATABLE = 2, // 010
    ARE_EXTERNAL = 1     // 001
} AREType;

#endif /* CONSTANTS_H */

================
File: include/data_generation.h
================
#ifndef DATA_GENERATION_H
#define DATA_GENERATION_H

#include <stdbool.h>
#include <stdio.h>

/* Constants */
#define MAX_DATA_SIZE 1000
#define MAX_DATA_VALUE 8191  // Maximum positive value for 14-bit signed integer
#define MIN_DATA_VALUE -8192 // Minimum negative value for 14-bit signed integer

/* Function Prototypes */

/* Process .data directive */
bool process_data_directive(const char *operands);

/* Process .string directive */
bool process_string_directive(const char *operands);

/* Reset the data counter */
void reset_data_counter();

/* Get the current value of the data counter */
int get_data_counter();

/* Write the data image to the output file */
void write_data_image(FILE *file);

/* Helper functions */
static bool validate_number(long value);
static bool add_to_data_image(int value);

/* Extern declarations for functions from other modules that data_generation.c might use */
extern int string_to_int(const char *str, bool *success);
extern void trim(char *str);

#endif /* DATA_GENERATION_H */

================
File: include/first_pass.h
================
#ifndef FIRST_PASS_H
#define FIRST_PASS_H

#include <stdbool.h>

/* Constants */
#define MAX_LINE_LENGTH 80
#define MAX_LABEL_LENGTH 31
#define MAX_OPERATION_LENGTH 10

/* Function Prototypes */

/* Main function for the first pass */
bool first_pass(const char *filename);

/* Helper functions */
static bool process_line(const char *line, int line_number);
static bool process_data(const char *operands);
static bool process_string(const char *operands);
static bool process_entry_extern(const char *operation, const char *operands);
static bool process_instruction(const char *operation, const char *operands);
static int get_instruction_length(const char *operation, const char *operands);

/* Extern declarations for functions from other modules that first_pass.c might use */
extern bool add_symbol(const char *name, int value, int type);
extern bool is_valid_label(const char *label);
extern bool is_reserved_word(const char *word);
extern void update_data_symbols(int ic_value);

/* Extern declarations for global variables that first_pass.c might use */
extern int IC;  /* Instruction Counter */
extern int DC;  /* Data Counter */

#endif /* FIRST_PASS_H */

================
File: include/macro_processor.h
================
#ifndef MACRO_PROCESSOR_H
#define MACRO_PROCESSOR_H

#include <stdbool.h>

/* Constants */
#define MAX_MACRO_NAME 31
#define MAX_MACRO_LINES 100
#define MAX_LINE_LENGTH 80
#define MAX_MACROS 100

/* Structs */
typedef struct {
    char name[MAX_MACRO_NAME + 1];
    char lines[MAX_MACRO_LINES][MAX_LINE_LENGTH + 1];
    int line_count;
} Macro;

/* Function Prototypes */

/* Main function to process macros */
bool process_macros(const char *input_filename, const char *output_filename);

/* Helper functions */
static bool is_macro_definition(const char *line, char *macro_name);
static bool is_macro_end(const char *line);
static bool is_macro_call(const char *line, char *macro_name);
static void add_macro(const char *name, FILE *input);
static void expand_macro(const char *name, FILE *output);

/* Extern declarations for functions from other modules that macro_processor.c might use */
extern bool is_empty_or_comment(const char *line);
extern void trim(char *str);

#endif /* MACRO_PROCESSOR_H */

================
File: include/second_pass.h
================
#ifndef SECOND_PASS_H
#define SECOND_PASS_H

#include <stdbool.h>
#include <stdio.h>

#include "symbol_table.h"

/* Constants */
#define MAX_LINE_LENGTH 80
#define MAX_LABEL_LENGTH 31
#define MAX_OPERATION_LENGTH 10
#define MAX_OPERAND_LENGTH 20

/* Structs */
typedef struct {
    int first_word;
    int second_word;
    int third_word;
    bool second_word_exists;
    bool third_word_exists;
    bool is_external_reference;
    char external_symbol[MAX_LABEL_LENGTH + 1];
} MachineCode;

/* Function Prototypes */

/* Main function for the second pass */
bool second_pass(const char *input_filename, const char *ob_filename, 
                 const char *ext_filename, const char *ent_filename);

/* Helper functions */
static bool process_line_second_pass(const char *line, int line_number, FILE *ob_file, FILE *ext_file, FILE *ent_file);
static bool process_entry(const char *operands, FILE *ent_file);
static bool process_instruction_second_pass(const char *operation, const char *operands, FILE *ob_file, FILE *ext_file);
static void write_data_section(FILE *ob_file);

/* Extern declarations for functions from other modules that second_pass.c might use */
extern bool generate_machine_code(const char *operation, const char *operands, MachineCode *code);
extern bool is_empty_or_comment(const char *line);
extern bool parse_line(const char *line, char *label, char *operation, char *operands);
extern Symbol *get_symbol(const char *name);
extern bool is_external_symbol(const char *name);
extern void get_entry_symbols(EntrySymbol *entries, int *count);

/* Extern declarations for global variables that second_pass.c might use */
extern int IC;  /* Instruction Counter */
extern int DC;  /* Data Counter */

#endif /* SECOND_PASS_H */

================
File: include/symbol_table.h
================
#ifndef SYMBOL_TABLE_H
#define SYMBOL_TABLE_H

#include <stdbool.h>

/* Constants */
#define MAX_SYMBOLS 1000
#define MAX_SYMBOL_LENGTH 31
#define MAX_ENTRIES 100

/* Enums */
typedef enum {
    SYMBOL_CODE,
    SYMBOL_DATA,
    SYMBOL_EXTERNAL,
    SYMBOL_ENTRY
} SymbolType;

/* Structs */
typedef struct {
    char name[MAX_SYMBOL_LENGTH + 1];
    int value;
    SymbolType type;
} Symbol;

typedef struct {
    char name[MAX_SYMBOL_LENGTH + 1];
    int value;
} EntrySymbol;

/* Function Prototypes */

/* Initialize the symbol table */
void initialize_symbol_table();

/* Add a new symbol to the table */
bool add_symbol(const char *name, int value, SymbolType type);

/* Get a symbol from the table */
Symbol *get_symbol(const char *name);

/* Update the value of an existing symbol */
bool update_symbol_value(const char *name, int new_value);

/* Update all data symbols by adding the final IC value */
void update_data_symbols(int ic_value);

/* Print the entire symbol table (for debugging) */
void print_symbol_table();

/* Check if a symbol is marked as external */
bool is_external_symbol(const char *name);

/* Get all symbols marked as entries */
void get_entry_symbols(EntrySymbol *entries, int *count);

#endif /* SYMBOL_TABLE_H */

================
File: include/utils.h
================
#ifndef UTILS_H
#define UTILS_H

#include <stdbool.h>

/* Constants */
#define MAX_LINE_LENGTH 80
#define MAX_LABEL_LENGTH 31
#define MAX_OPERATION_LENGTH 10
#define MAX_OPERAND_LENGTH 20

/* Function Prototypes */

/* Check if a line is empty or a comment */
bool is_empty_or_comment(const char *line);

/* Parse a line into label, operation, and operands */
bool parse_line(const char *line, char *label, char *operation, char *operands);

/* Remove leading and trailing whitespace from a string */
void trim(char *str);

/* Convert a string to an integer, checking for validity and range */
int string_to_int(const char *str, bool *success);

/* Check if a label is valid */
bool is_valid_label(const char *label);

/* Check if a word is a reserved word in the assembly language */
bool is_reserved_word(const char *word);

/* Convert an integer to its binary string representation */
void int_to_binary_string(int value, char *binary, int num_bits);

/* Convert a binary string to an integer */
int binary_string_to_int(const char *binary);

/* Check if a string represents a valid integer within the specified range */
bool is_valid_integer(const char *str, int min, int max);

/* Function to log errors */
void log_error(const char *format, ...);

/* Function to log warnings */
void log_warning(const char *format, ...);

#endif /* UTILS_H */

================
File: makefile
================
# Compiler settings
CC = gcc
CFLAGS = -Wall -Wextra -ansi -pedantic -g

# Directories
SRC_DIR = src
INC_DIR = include
OBJ_DIR = obj
BIN_DIR = bin

# Source files
SOURCES = $(wildcard $(SRC_DIR)/*.c)
OBJECTS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SOURCES))

# Header files
HEADERS = $(wildcard $(INC_DIR)/*.h)

# Executable name
EXECUTABLE = $(BIN_DIR)/assembler

# Default target
all: $(EXECUTABLE)

# Rule to create the executable
$(EXECUTABLE): $(OBJECTS) | $(BIN_DIR)
	$(CC) $(CFLAGS) $^ -o $@

# Rule to compile source files into object files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c $(HEADERS) | $(OBJ_DIR)
	$(CC) $(CFLAGS) -I$(INC_DIR) -c $< -o $@

# Rule to create directories
$(BIN_DIR) $(OBJ_DIR):
	mkdir -p $@

# Clean target
clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR)

# Phony targets
.PHONY: all clean

# Include dependencies
-include $(OBJECTS:.o=.d)

# Rule to generate dependency files
$(OBJ_DIR)/%.d: $(SRC_DIR)/%.c | $(OBJ_DIR)
	@set -e; rm -f $@; \
	$(CC) -MM -I$(INC_DIR) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,$(OBJ_DIR)/\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$

================
File: obj/assembler.d
================
obj/assembler.o obj/assembler.d : src/assembler.c include/assembler.h include/first_pass.h \
 include/second_pass.h include/symbol_table.h include/macro_processor.h \
 include/utils.h

================
File: obj/code_generation.d
================
obj/code_generation.o obj/code_generation.d : src/code_generation.c include/code_generation.h \
 include/symbol_table.h include/utils.h

================
File: obj/data_generation.d
================
obj/data_generation.o obj/data_generation.d : src/data_generation.c include/data_generation.h

================
File: obj/first_pass.d
================
obj/first_pass.o obj/first_pass.d : src/first_pass.c include/first_pass.h \
 include/symbol_table.h include/utils.h include/constants.h

================
File: obj/macro_processor.d
================
obj/macro_processor.o obj/macro_processor.d : src/macro_processor.c include/macro_processor.h

================
File: obj/second_pass.d
================
obj/second_pass.o obj/second_pass.d : src/second_pass.c include/second_pass.h \
 include/symbol_table.h include/symbol_table.h include/code_generation.h \
 include/utils.h include/constants.h

================
File: obj/symbol_table.d
================
obj/symbol_table.o obj/symbol_table.d : src/symbol_table.c include/symbol_table.h

================
File: obj/utils.d
================
obj/utils.o obj/utils.d : src/utils.c include/utils.h

================
File: src/assembler.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "assembler.h"
#include "first_pass.h"
#include "second_pass.h"
#include "macro_processor.h"
#include "utils.h"

#define MAX_FILENAME 256

int main(int argc, char *argv[]) {
    int i;
    char input_filename[MAX_FILENAME];
    char am_filename[MAX_FILENAME];
    char ob_filename[MAX_FILENAME];
    char ext_filename[MAX_FILENAME];
    char ent_filename[MAX_FILENAME];

    /* Check if there are input files */
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file1> <file2> ...\n", argv[0]);
        exit(1);
    }

    /* Process each input file */
    for (i = 1; i < argc; i++) {
        /* Construct filenames */
        snprintf(input_filename, MAX_FILENAME, "%s.as", argv[i]);
        snprintf(am_filename, MAX_FILENAME, "%s.am", argv[i]);
        snprintf(ob_filename, MAX_FILENAME, "%s.ob", argv[i]);
        snprintf(ext_filename, MAX_FILENAME, "%s.ext", argv[i]);
        snprintf(ent_filename, MAX_FILENAME, "%s.ent", argv[i]);

        /* Macro processing stage */
        if (!process_macros(input_filename, am_filename)) {
            fprintf(stderr, "Error processing macros in file %s\n", input_filename);
            continue;  /* Move to the next file */
        }

        /* First pass */
        if (!first_pass(am_filename)) {
            fprintf(stderr, "Error in first pass for file %s\n", am_filename);
            continue;  /* Move to the next file */
        }

        /* Second pass */
        if (!second_pass(am_filename, ob_filename, ext_filename, ent_filename)) {
            fprintf(stderr, "Error in second pass for file %s\n", am_filename);
            continue;  /* Move to the next file */
        }

        printf("Successfully assembled %s\n", input_filename);

        /* Clean up any resources if necessary */
        cleanup_resources();
    }

    return 0;
}

void cleanup_resources() {
    /* Free any global resources, close files, etc. */
    /* This function should be implemented based on your specific needs */
}

================
File: src/code_generation.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "code_generation.h"
#include "symbol_table.h"
#include "utils.h"

#define MAX_OPERANDS 2

typedef struct {
    const char *name;
    int opcode;
    int operand_count;
} Instruction;

static const Instruction instruction_set[] = {
    {"mov", 0, 2},
    {"cmp", 1, 2},
    {"add", 2, 2},
    {"sub", 3, 2},
    {"lea", 4, 2},
    {"clr", 5, 1},
    {"not", 6, 1},
    {"inc", 7, 1},
    {"dec", 8, 1},
    {"jmp", 9, 1},
    {"bne", 10, 1},
    {"red", 11, 1},
    {"prn", 12, 1},
    {"jsr", 13, 1},
    {"rts", 14, 0},
    {"stop", 15, 0}
};

static int get_register_number(const char *reg);
static int get_addressing_mode(const char *operand);
static bool encode_operand(const char *operand, int *value, bool *is_external);

bool generate_machine_code(const char *operation, const char *operands, MachineCode *code) {
    char op1[MAX_OPERAND_LENGTH] = {0}, op2[MAX_OPERAND_LENGTH] = {0};
    int opcode = -1, src_addr = 0, dst_addr = 0;
    int operand_count = 0;

    // Find the instruction
    for (size_t i = 0; i < sizeof(instruction_set) / sizeof(Instruction); i++) {
        if (strcmp(operation, instruction_set[i].name) == 0) {
            opcode = instruction_set[i].opcode;
            operand_count = instruction_set[i].operand_count;
            break;
        }
    }

    if (opcode == -1) {
        fprintf(stderr, "Unknown operation: %s\n", operation);
        return false;
    }

    // Parse operands
    if (operand_count > 0) {
        sscanf(operands, "%s %s", op1, op2);
    }

    // Encode first word
    code->first_word = (opcode << 6);
    if (operand_count > 0) {
        src_addr = get_addressing_mode(op1);
        dst_addr = get_addressing_mode(op2);
        code->first_word |= (src_addr << 4) | (dst_addr << 2);
    }
    code->first_word |= 0b100;  // A,R,E bits: Absolute

    // Encode operands
    code->second_word_exists = false;
    code->third_word_exists = false;
    code->is_external_reference = false;

    if (operand_count > 0) {
        int value;
        bool is_external;

        if (encode_operand(op1, &value, &is_external)) {
            code->second_word = value;
            code->second_word_exists = true;
            if (is_external) {
                code->is_external_reference = true;
                strncpy(code->external_symbol, op1, MAX_SYMBOL_LENGTH);
            }
        }

        if (operand_count > 1) {
            if (encode_operand(op2, &value, &is_external)) {
                code->third_word = value;
                code->third_word_exists = true;
                if (is_external) {
                    code->is_external_reference = true;
                    strncpy(code->external_symbol, op2, MAX_SYMBOL_LENGTH);
                }
            }
        }
    }

    return true;
}

static int get_register_number(const char *reg) {
    if (reg[0] == 'r' && reg[1] >= '0' && reg[1] <= '7' && reg[2] == '\0') {
        return reg[1] - '0';
    }
    return -1;
}

static int get_addressing_mode(const char *operand) {
    if (operand[0] == '#') return 0;  // Immediate
    if (operand[0] == '*') return 2;  // Register indirect
    if (get_register_number(operand) != -1) return 3;  // Register direct
    return 1;  // Direct
}

static bool encode_operand(const char *operand, int *value, bool *is_external) {
    int reg_num;
    *is_external = false;

    if (operand[0] == '#') {
        *value = atoi(operand + 1);
        return true;
    }

    if ((reg_num = get_register_number(operand)) != -1) {
        *value = reg_num;
        return true;
    }

    if (operand[0] == '*') {
        reg_num = get_register_number(operand + 1);
        if (reg_num != -1) {
            *value = reg_num;
            return true;
        }
    }

    // Symbol
    Symbol *symbol = get_symbol(operand);
    if (symbol) {
        *value = symbol->value;
        *is_external = (symbol->type == SYMBOL_EXTERNAL);
        return true;
    }

    fprintf(stderr, "Invalid operand: %s\n", operand);
    return false;
}

================
File: src/data_generation.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "data_generation.h"

#define MAX_DATA_SIZE 1000

static int data_image[MAX_DATA_SIZE];
static int data_counter = 0;

bool process_data_directive(const char *operands) {
    char *token;
    char *rest = strdup(operands);
    
    if (!rest) {
        fprintf(stderr, "Memory allocation failed\n");
        return false;
    }

    while ((token = strtok_r(rest, ",", &rest))) {
        // Remove leading and trailing whitespace
        while (isspace(*token)) token++;
        char *end = token + strlen(token) - 1;
        while (end > token && isspace(*end)) end--;
        *(end + 1) = 0;

        // Convert to integer
        char *endptr;
        long value = strtol(token, &endptr, 10);

        if (*endptr != '\0') {
            fprintf(stderr, "Invalid number in .data directive: %s\n", token);
            free(rest);
            return false;
        }

        if (value < -8192 || value > 8191) {
            fprintf(stderr, "Number out of range in .data directive: %ld\n", value);
            free(rest);
            return false;
        }

        if (data_counter >= MAX_DATA_SIZE) {
            fprintf(stderr, "Data segment full\n");
            free(rest);
            return false;
        }

        data_image[data_counter++] = (int)value;
    }

    free(rest);
    return true;
}

bool process_string_directive(const char *operands) {
    // Remove leading and trailing whitespace
    while (isspace(*operands)) operands++;
    const char *end = operands + strlen(operands) - 1;
    while (end > operands && isspace(*end)) end--;

    // Check if the string is properly enclosed in quotes
    if (*operands != '"' || *end != '"' || operands == end) {
        fprintf(stderr, "Invalid string format in .string directive\n");
        return false;
    }

    // Process the string content
    for (const char *c = operands + 1; c < end; c++) {
        if (data_counter >= MAX_DATA_SIZE) {
            fprintf(stderr, "Data segment full\n");
            return false;
        }
        data_image[data_counter++] = (int)*c;
    }

    // Add null terminator
    if (data_counter >= MAX_DATA_SIZE) {
        fprintf(stderr, "Data segment full\n");
        return false;
    }
    data_image[data_counter++] = 0;

    return true;
}

void reset_data_counter() {
    data_counter = 0;
}

int get_data_counter() {
    return data_counter;
}

void write_data_image(FILE *file) {
    for (int i = 0; i < data_counter; i++) {
        fprintf(file, "%04d %05o\n", i + 100, data_image[i] & 0x7FFF);
    }
}

================
File: src/first_pass.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "first_pass.h"
#include "symbol_table.h"
#include "utils.h"
#include "constants.h"

#define MAX_LINE_LENGTH 80

static int IC = 100;  /* Instruction Counter */
static int DC = 0;    /* Data Counter */

bool first_pass(const char *filename) {
    FILE *file = fopen(filename, "r");
    char line[MAX_LINE_LENGTH];
    int line_number = 0;
    bool success = true;

    if (!file) {
        fprintf(stderr, "Error opening file %s\n", filename);
        return false;
    }

    initialize_symbol_table();

    while (fgets(line, sizeof(line), file)) {
        line_number++;
        
        /* Remove newline character if present */
        line[strcspn(line, "\n")] = 0;

        /* Skip empty lines and comments */
        if (is_empty_or_comment(line)) {
            continue;
        }

        /* Process the line */
        if (!process_line(line, line_number)) {
            fprintf(stderr, "Error in line %d: %s\n", line_number, line);
            success = false;
        }
    }

    fclose(file);

    /* Update data symbols */
    update_data_symbols(IC);

    return success;
}

static bool process_line(const char *line, int line_number) {
    char label[MAX_LABEL_LENGTH] = {0};
    char operation[MAX_OPERATION_LENGTH] = {0};
    char operands[MAX_LINE_LENGTH] = {0};

    /* Parse the line */
    if (!parse_line(line, label, operation, operands)) {
        return false;
    }

    /* Handle label if present */
    if (label[0] != '\0') {
        if (!add_symbol(label, IC, SYMBOL_CODE)) {
            fprintf(stderr, "Error adding symbol %s\n", label);
            return false;
        }
    }

    /* Process operation */
    if (strcmp(operation, "data") == 0) {
        return process_data(operands);
    } else if (strcmp(operation, "string") == 0) {
        return process_string(operands);
    } else if (strcmp(operation, "entry") == 0 || strcmp(operation, "extern") == 0) {
        return process_entry_extern(operation, operands);
    } else {
        return process_instruction(operation, operands);
    }
}

static bool process_data(const char *operands) {
    /* Implementation for .data directive */
    /* Parse numbers, update DC, etc. */
    /* ... */
    return true;
}

static bool process_string(const char *operands) {
    /* Implementation for .string directive */
    /* Parse string, update DC, etc. */
    /* ... */
    return true;
}

static bool process_entry_extern(const char *operation, const char *operands) {
    if (strcmp(operation, "extern") == 0) {
        return add_symbol(operands, 0, SYMBOL_EXTERNAL);
    }
    /* For 'entry', we just ignore it in the first pass */
    return true;
}

static bool process_instruction(const char *operation, const char *operands) {
    /* Determine instruction length and update IC */
    int instruction_length = get_instruction_length(operation, operands);
    if (instruction_length == -1) {
        return false;  /* Invalid instruction */
    }
    IC += instruction_length;
    return true;
}

static int get_instruction_length(const char *operation, const char *operands) {
    /* Implement logic to determine instruction length based on operation and operands */
    /* ... */
    return 0;  /* Placeholder return */
}

static void update_data_symbols(int final_IC) {
    /* Update all data symbols by adding final IC */
    /* ... */
}

================
File: src/macro_processor.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "macro_processor.h"

#define MAX_MACRO_NAME 31
#define MAX_MACRO_LINES 100
#define MAX_LINE_LENGTH 80
#define MAX_MACROS 100

typedef struct {
    char name[MAX_MACRO_NAME + 1];
    char lines[MAX_MACRO_LINES][MAX_LINE_LENGTH + 1];
    int line_count;
} Macro;

static Macro macro_table[MAX_MACROS];
static int macro_count = 0;

static bool is_macro_definition(const char *line, char *macro_name);
static bool is_macro_end(const char *line);
static bool is_macro_call(const char *line, char *macro_name);
static void add_macro(const char *name, FILE *input);
static void expand_macro(const char *name, FILE *output);

bool process_macros(const char *input_filename, const char *output_filename) {
    FILE *input = fopen(input_filename, "r");
    FILE *output = fopen(output_filename, "w");
    char line[MAX_LINE_LENGTH + 1];
    char macro_name[MAX_MACRO_NAME + 1];

    if (!input || !output) {
        fprintf(stderr, "Error opening files for macro processing\n");
        return false;
    }

    while (fgets(line, sizeof(line), input)) {
        if (is_macro_definition(line, macro_name)) {
            add_macro(macro_name, input);
        } else if (is_macro_call(line, macro_name)) {
            expand_macro(macro_name, output);
        } else {
            fputs(line, output);
        }
    }

    fclose(input);
    fclose(output);
    return true;
}

static bool is_macro_definition(const char *line, char *macro_name) {
    return (sscanf(line, "macro %s", macro_name) == 1);
}

static bool is_macro_end(const char *line) {
    return (strncmp(line, "endmacro", 8) == 0);
}

static bool is_macro_call(const char *line, char *macro_name) {
    for (int i = 0; i < macro_count; i++) {
        if (strncmp(line, macro_table[i].name, strlen(macro_table[i].name)) == 0) {
            strcpy(macro_name, macro_table[i].name);
            return true;
        }
    }
    return false;
}

static void add_macro(const char *name, FILE *input) {
    if (macro_count >= MAX_MACROS) {
        fprintf(stderr, "Maximum number of macros exceeded\n");
        return;
    }

    Macro *macro = &macro_table[macro_count++];
    strncpy(macro->name, name, MAX_MACRO_NAME);
    macro->name[MAX_MACRO_NAME] = '\0';
    macro->line_count = 0;

    char line[MAX_LINE_LENGTH + 1];
    while (fgets(line, sizeof(line), input) && !is_macro_end(line)) {
        if (macro->line_count < MAX_MACRO_LINES) {
            strncpy(macro->lines[macro->line_count], line, MAX_LINE_LENGTH);
            macro->lines[macro->line_count][MAX_LINE_LENGTH] = '\0';
            macro->line_count++;
        } else {
            fprintf(stderr, "Macro '%s' exceeds maximum lines\n", name);
            break;
        }
    }
}

static void expand_macro(const char *name, FILE *output) {
    for (int i = 0; i < macro_count; i++) {
        if (strcmp(macro_table[i].name, name) == 0) {
            for (int j = 0; j < macro_table[i].line_count; j++) {
                fputs(macro_table[i].lines[j], output);
            }
            return;
        }
    }
    fprintf(stderr, "Macro '%s' not found\n", name);
}

================
File: src/second_pass.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "second_pass.h"
#include "symbol_table.h"
#include "code_generation.h"
#include "utils.h"
#include "constants.h"

#define MAX_LINE_LENGTH 80
#define MAX_LABEL_LENGTH 31
#define MAX_OPERATION_LENGTH 10

static int IC = 100;  /* Instruction Counter */
static int DC = 0;    /* Data Counter */

bool second_pass(const char *input_filename, const char *ob_filename, 
                 const char *ext_filename, const char *ent_filename) {
    FILE *input_file, *ob_file, *ext_file, *ent_file;
    char line[MAX_LINE_LENGTH];
    int line_number = 0;
    bool success = true;

    input_file = fopen(input_filename, "r");
    ob_file = fopen(ob_filename, "w");
    ext_file = fopen(ext_filename, "w");
    ent_file = fopen(ent_filename, "w");

    if (!input_file || !ob_file || !ext_file || !ent_file) {
        fprintf(stderr, "Error opening files for second pass\n");
        return false;
    }

    /* Write header to object file */
    fprintf(ob_file, "%d %d\n", IC - 100, DC);

    while (fgets(line, sizeof(line), input_file)) {
        line_number++;
        
        /* Remove newline character if present */
        line[strcspn(line, "\n")] = 0;

        /* Skip empty lines and comments */
        if (is_empty_or_comment(line)) {
            continue;
        }

        /* Process the line */
        if (!process_line_second_pass(line, line_number, ob_file, ext_file, ent_file)) {
            fprintf(stderr, "Error in line %d: %s\n", line_number, line);
            success = false;
        }
    }

    /* Write data section to object file */
    write_data_section(ob_file);

    fclose(input_file);
    fclose(ob_file);
    fclose(ext_file);
    fclose(ent_file);

    return success;
}

static bool process_line_second_pass(const char *line, int line_number, FILE *ob_file, FILE *ext_file, FILE *ent_file) {
    char label[MAX_LABEL_LENGTH] = {0};
    char operation[MAX_OPERATION_LENGTH] = {0};
    char operands[MAX_LINE_LENGTH] = {0};

    /* Parse the line */
    if (!parse_line(line, label, operation, operands)) {
        return false;
    }

    /* Process operation */
    if (strcmp(operation, "data") == 0 || strcmp(operation, "string") == 0) {
        /* Skip data and string directives in second pass */
        return true;
    } else if (strcmp(operation, "entry") == 0) {
        return process_entry(operands, ent_file);
    } else if (strcmp(operation, "extern") == 0) {
        /* Skip extern directives in second pass */
        return true;
    } else {
        return process_instruction_second_pass(operation, operands, ob_file, ext_file);
    }
}

static bool process_entry(const char *operands, FILE *ent_file) {
    Symbol *symbol = get_symbol(operands);
    if (!symbol) {
        fprintf(stderr, "Entry symbol %s not found\n", operands);
        return false;
    }
    fprintf(ent_file, "%s %04d\n", operands, symbol->value);
    return true;
}

static bool process_instruction_second_pass(const char *operation, const char *operands, FILE *ob_file, FILE *ext_file) {
    MachineCode code;
    if (!generate_machine_code(operation, operands, &code)) {
        return false;
    }

    /* Write machine code to object file */
    fprintf(ob_file, "%04d %05o\n", IC, code.first_word);
    IC++;

    if (code.second_word_exists) {
        fprintf(ob_file, "%04d %05o\n", IC, code.second_word);
        IC++;
    }

    if (code.third_word_exists) {
        fprintf(ob_file, "%04d %05o\n", IC, code.third_word);
        IC++;
    }

    /* Handle external references */
    if (code.is_external_reference) {
        fprintf(ext_file, "%s %04d\n", code.external_symbol, IC - 1);
    }

    return true;
}

static void write_data_section(FILE *ob_file) {
    /* Write data section to object file */
    /* This function should iterate through the data image and write it to the object file */
    /* ... */
}

================
File: src/symbol_table.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "symbol_table.h"

#define MAX_SYMBOLS 1000

typedef struct {
    char name[MAX_SYMBOL_LENGTH];
    int value;
    SymbolType type;
} Symbol;

static Symbol symbol_table[MAX_SYMBOLS];
static int symbol_count = 0;

void initialize_symbol_table() {
    symbol_count = 0;
}

bool add_symbol(const char *name, int value, SymbolType type) {
    if (symbol_count >= MAX_SYMBOLS) {
        fprintf(stderr, "Symbol table is full\n");
        return false;
    }

    if (get_symbol(name) != NULL) {
        fprintf(stderr, "Symbol %s already exists\n", name);
        return false;
    }

    Symbol *symbol = &symbol_table[symbol_count++];
    strncpy(symbol->name, name, MAX_SYMBOL_LENGTH - 1);
    symbol->name[MAX_SYMBOL_LENGTH - 1] = '\0';  // Ensure null-termination
    symbol->value = value;
    symbol->type = type;

    return true;
}

Symbol *get_symbol(const char *name) {
    for (int i = 0; i < symbol_count; i++) {
        if (strcmp(symbol_table[i].name, name) == 0) {
            return &symbol_table[i];
        }
    }
    return NULL;
}

bool update_symbol_value(const char *name, int new_value) {
    Symbol *symbol = get_symbol(name);
    if (symbol == NULL) {
        return false;
    }
    symbol->value = new_value;
    return true;
}

void update_data_symbols(int ic_value) {
    for (int i = 0; i < symbol_count; i++) {
        if (symbol_table[i].type == SYMBOL_DATA) {
            symbol_table[i].value += ic_value;
        }
    }
}

void print_symbol_table() {
    printf("Symbol Table:\n");
    printf("Name\t\tValue\tType\n");
    for (int i = 0; i < symbol_count; i++) {
        printf("%-15s\t%d\t", symbol_table[i].name, symbol_table[i].value);
        switch (symbol_table[i].type) {
            case SYMBOL_CODE: printf("Code\n"); break;
            case SYMBOL_DATA: printf("Data\n"); break;
            case SYMBOL_EXTERNAL: printf("External\n"); break;
            case SYMBOL_ENTRY: printf("Entry\n"); break;
        }
    }
}

bool is_external_symbol(const char *name) {
    Symbol *symbol = get_symbol(name);
    return symbol != NULL && symbol->type == SYMBOL_EXTERNAL;
}

void get_entry_symbols(EntrySymbol *entries, int *count) {
    *count = 0;
    for (int i = 0; i < symbol_count && *count < MAX_ENTRIES; i++) {
        if (symbol_table[i].type == SYMBOL_ENTRY) {
            strncpy(entries[*count].name, symbol_table[i].name, MAX_SYMBOL_LENGTH - 1);
            entries[*count].name[MAX_SYMBOL_LENGTH - 1] = '\0';  // Ensure null-termination
            entries[*count].value = symbol_table[i].value;
            (*count)++;
        }
    }
}

================
File: src/utils.c
================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "utils.h"

bool is_empty_or_comment(const char *line) {
    while (*line) {
        if (!isspace(*line)) {
            return (*line == ';');  // True if it's a comment, false otherwise
        }
        line++;
    }
    return true;  // Empty line
}

bool parse_line(const char *line, char *label, char *operation, char *operands) {
    const char *start = line;
    
    // Skip leading whitespace
    while (isspace(*start)) start++;

    // Check for empty line or comment
    if (*start == '\0' || *start == ';') {
        *label = *operation = *operands = '\0';
        return true;
    }

    // Parse label
    const char *colon = strchr(start, ':');
    if (colon) {
        size_t label_length = colon - start;
        if (label_length >= MAX_LABEL_LENGTH) {
            fprintf(stderr, "Label too long\n");
            return false;
        }
        strncpy(label, start, label_length);
        label[label_length] = '\0';
        start = colon + 1;
    } else {
        *label = '\0';
    }

    // Skip whitespace after label
    while (isspace(*start)) start++;

    // Parse operation
    const char *space = strchr(start, ' ');
    if (space) {
        size_t operation_length = space - start;
        if (operation_length >= MAX_OPERATION_LENGTH) {
            fprintf(stderr, "Operation too long\n");
            return false;
        }
        strncpy(operation, start, operation_length);
        operation[operation_length] = '\0';
        start = space + 1;
    } else {
        strcpy(operation, start);
        *operands = '\0';
        return true;
    }

    // Skip whitespace after operation
    while (isspace(*start)) start++;

    // Parse operands
    strcpy(operands, start);

    // Remove trailing whitespace from operands
    char *end = operands + strlen(operands) - 1;
    while (end > operands && isspace(*end)) end--;
    *(end + 1) = '\0';

    return true;
}

void trim(char *str) {
    char *end;

    // Trim leading space
    while(isspace((unsigned char)*str)) str++;

    if(*str == 0)  // All spaces?
        return;

    // Trim trailing space
    end = str + strlen(str) - 1;
    while(end > str && isspace((unsigned char)*end)) end--;

    // Write new null terminator character
    end[1] = '\0';
}

int string_to_int(const char *str, bool *success) {
    char *endptr;
    long value = strtol(str, &endptr, 10);

    if (endptr == str || *endptr != '\0') {
        *success = false;
        return 0;
    }

    if (value < -8192 || value > 8191) {
        *success = false;
        return 0;
    }

    *success = true;
    return (int)value;
}

bool is_valid_label(const char *label) {
    if (!isalpha(*label)) {
        return false;  // First character must be a letter
    }

    while (*label) {
        if (!isalnum(*label)) {
            return false;  // Must contain only letters and digits
        }
        label++;
    }

    return true;
}

bool is_reserved_word(const char *word) {
    const char *reserved_words[] = {
        "mov", "cmp", "add", "sub", "lea", "clr", "not", "inc", "dec",
        "jmp", "bne", "red", "prn", "jsr", "rts", "stop", "data", "string",
        "entry", "extern", "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7"
    };

    for (size_t i = 0; i < sizeof(reserved_words) / sizeof(reserved_words[0]); i++) {
        if (strcmp(word, reserved_words[i]) == 0) {
            return true;
        }
    }

    return false;
}
